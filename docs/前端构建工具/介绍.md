# 前端工程化发展历程

## 引言

前端工程化的核心是构建工具。

### 什么是构建

![](https://pic1.zhimg.com/v2-c621790cba13115eb95e1329de7ac4bc_b.jpg)

**构建**就是将我们开发出的**源代码**转换成可用于**生产环境部署**的代码

为了生成可用于生产环境的前端核心代码，构建工具对代码实现了如代码转换（Babel）、Tree shaking（去除dead code）、code spliting（代码分片，按需加载）等功能。

### 构建工具可以做什么

![](https://pic1.zhimg.com/v2-60986bb2deeec7490d95bdbdce893e34_b.jpg)

对上面的每一项进行解释就是：

1. 开发服务器：代码热更新，提高整体开发效率
2. source map：实现生成代码到源码的映射，快速定位错误代码
3. tree shaking：去除无用的dead code
4. 代码分割：比如webpack的splitChunks
5. 代码规范、风格校验：Eslint、Prettier
6. 插件体系：提供插件供开发者实现更丰富的构建能力
7. 抹平代码兼容性：Babel提供polyfill能力
8. 抹平框架之间的差异性：生成浏览器可执行的js代码
9. 代码/资源压缩混淆：减小代码的体积
10. 各种开发资源转换

### 前端构建工具进化史

#### 无模块化时代

##### YUI Tool + Ant

##### JS内联外联

#### 社区模块化时代

##### AMD/CMD—异步模块加载

1. AMD（RequireJS）：推崇依赖前置、提前执行
2. CMD（Sea.js）：推崇依赖就近、延迟执行

两种模块化规范实现的原理基本一致，只是各自坚持的理念不同。两者都是以异步的方式获取当前模块依赖的模块，不同的地方是AMD在获取到依赖的模块后立即执行，CMD在用到相关模块的位置再执行。

**解决的问题**

1. 根据依赖的引入维护代码的执行顺序，不需要调整HTML文件中的脚本顺序，依赖数组会自动侦测模块之间的依赖关系，自动插入页面
2. 全部变量污染问题：将模块的内容在函数nei实现，再利用闭包导出的变量通信，不存在全局变量污染问题

##### Grunt/Gulp

在Google Chrome推出V8 Engine后，基于V8的高性能和平台独立的特性，NodeJs的JS运行时现世。JS打破了浏览器的限制，有了文件读写的能力。NodeJS不仅在服务端领域占据了一席之地，也带动了前端工程化的发展。

##### Grunt

**Grunt**能够自动化的处理一些反复重复的任务，比如压缩、编译、单元测试、lint等。

##### Gulp

**Grunt**的I/O操作比较生硬，每个任务执行结束后都会将文件写入磁盘，下个任务执行时再将文件从磁盘中读出，这样就会导致：

1. 运行速度慢
2. 硬件压力大

**Gulp**引入了 **流**的概念，提供了一系列常用插件处理流，流可以在插件之间传递。而且Gulp设计简单，既可以单独使用，也可以结合别的工具一起使用。

##### Browserify

在Node.js中，**CommonJS**模块化规范是当时的主流规范。但是CommonJS使用的require语法是同步的，当代码执行到require方法时，必需要等模块加载完成后才会执行后面的代码。

同步**require**的方式在服务端是可行的，因为服务器只需要从本地磁盘中读取文件，速度很快。但是浏览器端，需要通过网络请求获取文件，网络环境和文件太大都会使页面不响应。

**browserify**致力于打包产出在浏览器端可以运行的CommonJS规范的代码。

**browserify**

browserify在运行时会进行 **AST语法树**分析，确定模块之间的依赖关系，生成依赖字典。然后包装每个模块，传入依赖字典以及自己实现的 **export** 和 **require**方法，生成一个可以在浏览器端执行的JS文件

browserify专注于JS打包，功能单一，一般配合Gulp一起使用。

##### Webpack

**基于配置**

**缺点**

1. 配置繁琐
2. 为了支持cjs和esm，做了polyfill，产物代码很难看

##### Rollup

面向未来的构建工具，完全基于ESM模块规范打包，率先提出Tree Shaking的概念。配置简单、易上手，是最流行的JS库打包工具。

**rollup**基于 **esm**，有强大的Tree-Shaking功能，使得构建产物足够简洁、体积足够小。但是考虑浏览器兼容性问题，还需要配合额外的polyfill库，或结合webpack使用。

##### ESBuild

**esbuild**是一个提供esm规范原生支持的新的模块打包工具，提供了类似webpack资源打包的能力，也拥有超高性能。

1. 支持ES6/CommonJS规范
2. 支持Tree-Shaking
3. 支持TypeScript
4. 支持JSX

根据官方提供的性能对比，esbuild的性能有百倍的提升

![](https://pic3.zhimg.com/v2-8410157e2f406b266bda46c2cc34045e_b.jpg)

1. 语言优势
   1. esbuild使用Go语言编写，在esbuild之前，前端构建工具都是基于Node使用JS编写。JavaScript 是一门解释性脚本语言，即使 V8 引擎做了大量优化（JWT 及时编译），本质上还是无法打破性能的瓶颈。而 Go 是一种编译型语言，在编译阶段就已经将源码转译为机器码，启动时只需要直接执行这些机器码即可。
   2. Go 天生具有多线程运行能力，而 JavaScript 本质上是一门单线程语言。esbuild 经过精心的设计，将代码 parse、代码生成等过程实现完全并行处理。
2. 性能至上
   1. esbuild 只提供现代 Web 应用最小的功能集合，所以其架构复杂度相对较小，更容易将性能做到极致
   2. 在 webpack、rollup 这类工具中， 我们习惯于使用多种第三方工作来增强工程能力。比如：babel、eslint、less 等。在代码经过多个工具流转的过程中，存在着很多性能上的浪费，比如：多次进行**代码 -> AST、AST -> 代码**的转换。esBuild 对此类工具完全进行了定制化重写，舍弃部分可维护性，追求极致的编译性能。

虽然esbuild性能很高，但是提供的功能非常基础，不适合直接用于生产环境，更适合最为底层的模块构建工具，在它基础上二次封装。

##### Vite

**vite**是下一代前端开发构建工具，提供noBundle的开发服务，内置丰富的功能，无需复杂配置。**vite**在开发环境底层基于esbuild提速，生产环境使用rollup打包。

**为什么vite开发服务快**

![](https://pic1.zhimg.com/v2-0f56f1467b9c07fb2bd9511c727b3b78_b.jpg)

1. 传统的基于bundle的服务
   1. 无论是 webpack 还是 rollup 提供给开发者使用的服务，都是基于构建结果的。
   2. 基于构建结果提供服务，意味着提供服务前一定要构建结束，随着项目膨胀，等待时间也会逐渐变长。
2. noBundle服务
   1. 对于 vite、snowpack 这类工具，提供的都是 noBundle 服务，无需等待构建，直接提供服务。
   2. 对于项目中的第三方依赖，仅在初次启动和依赖变化时重构建，会执行一个`依赖预构建`的过程。由于是基于 esBuild 做的构建，所以非常快。
   3. 对于项目代码，则会依赖于浏览器的 ESM 的支持，直接按需访问，不必全量构建。

**为什么在生产环境中使用rollup**

1. 由于浏览器的兼容性问题以及实际网络中使用 ESM 可能会造成 RTT 时间过长，所以仍然需要打包构建。

2. esbuild 虽然快，但是它还没有发布 1.0 稳定版本，另外 esbuild 对代码分割和 css 处理等支持较弱，所以生产环境仍然使用 rollup。

### 构建工具对比

![](https://pic1.zhimg.com/v2-7345722f7b19e078c0655acdc33c5f3c_b.jpg)

### Q & A

#### 为什么 webpack 构建产物看着很丑？

我们在使用 webpack 构建项目后，会发现打包出来的代码非常的“丑”，这是为什么？原因就是：webpack 支持多种模块规范，但是最后都会变成`commonJS规范`（webpack5 对纯 esm 做了一定的优化），但是浏览器不支持`commonJS规范`，于是 webpack 自己实现了`require`和`module.exports`，所以会有很多 polyfill 代码的注入。

#### webpack 按需加载的模块怎么在浏览器中运行？

在实际项目开发中，随着代码越写越多，构建后的 bundle 文件也会越来越大，我们往往按照种种策略对代码进行按需加载，将某部分代码在用户事件触发后再进行加载，那么 webpack 在运行时是怎么实现的呢？

其实原理很简单，就是以 JSONP 的方式加载按需的脚本，但是如何将这些异步模块使用起来就比较有意思了～

#### webpack构建流程

![](https://pic4.zhimg.com/v2-0d6cca017139579f188665cd4f16bc3b_b.jpg)

#### 为什么 Rollup 构建产物很干净？

1. rollup 只对 ESM 模块进行打包，对于 cjs 模块也会通过插件将其转化为 ESM 模块进行打包。所以不会像 webpack 有很多的代码注入。

2. rollup 对打包结果也支持多种 format 的输出，比如：esm、cjs、am 等等，但是 rollup 并不保证代码可靠运行，需要运行环境可靠支持。比如我们输出 esm 规范代码，代码运行时完全依赖高版本浏览器原生去支持 esm，rollup 不会像 webpack 一样注入一系列兼容代码。

3. rollup 实现了强大的 tree-shaking 能力。

#### 为什么 Vite 可以让代码直接运行在浏览器上？

前文我们提到，在开发环境时，我们使用 vite 开发，是无需打包的，直接利用浏览器对 ESM 的支持，就可以访问我们写的组件代码，但是一些组件代码文件往往不是 JS 文件，而是 `.ts`、`.tsx`、`.vue` 等类型的文件。这些文件浏览器肯定直接是识别不了的，vite 在这个过程中做了些什么？

总结：当用户访问 vite 提供的开发服务器时，对于浏览器不能直接识别的文件，服务器的一些中间件会将此类文件转换成浏览器认识的文件，从而保证正常访问。

## 参考文献

1. <https://zhuanlan.zhihu.com/p/610368281>

2. <https://link.zhihu.com/?target=https%3A//juejin.cn/post/7085613927249215525>
3. <https://link.zhihu.com/?target=https%3A//hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/>
4. <https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/SbJNbSVzSPSKBe2YStn2Zw>
